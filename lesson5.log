Практическое задание по теме «Операторы, фильтрация, сортировка и ограничение»
1. Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.
mysql> SELECT @my_time := now(); UPDATE vk.users set users.created_at = @my_time, users.updated_at = @my_time;
+---------------------+
| @my_time := now()   |
+---------------------+
| 2020-06-28 15:30:20 |
+---------------------+
1 row in set (0.05 sec)

Query OK, 100 rows affected (0.02 sec)
Rows matched: 100  Changed: 100  Warnings: 0
mysql>



2. Таблица users была неудачно спроектирована. 
Записи created_at и updated_at были заданы типом VARCHAR и в них долгое время помещались значения в формате 20.10.2017 8:10. 
Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.

!!! Делал чисто теоретически, не проверял, задание не совсем корректное, т.к. не указано какое время задано в 24часовом формате или 12 часовом.
UPDATE vk.users 
SET users.created_at = CASE 
	WHEN STR_TO_DATE( users.created_at, '%d.%m.%Y %H:%i' ) THEN
		STR_TO_DATE( users.created_at, '%d.%m.%Y %H:%i' )
	ELSE
		users.created_at
END CASE,

users.updated_at = CASE 
	WHEN STR_TO_DATE( users.updated_at, '%d.%m.%Y %H:%i' ) THEN
		STR_TO_DATE( users.updated_at, '%d.%m.%Y %H:%i' )
	ELSE
		users.updated_at
END CASE;
ALTER TABLE `vk`.`users` MODIFY COLUMN `created_at` datetime ( 0 ) NULL DEFAULT NULL AFTER `phone`;
ALTER TABLE `vk`.`users` MODIFY COLUMN `updated_at` datetime ( 0 ) NULL DEFAULT NULL AFTER `created_at`;

3. В таблице складских запасов storehouses_products в поле value могут встречаться самые разные цифры: 0, 
если товар закончился и выше нуля, если на складе имеются запасы. 
Необходимо отсортировать записи таким образом, чтобы они выводились в порядке увеличения значения value. 
Однако нулевые запасы должны выводиться в конце, после всех записей.
mysql> SELECT * FROM warehouse ORDER by value;
+----+-------+
| id | value |
+----+-------+
|  7 |     0 |
| 10 |     0 |
| 12 |     0 |
|  1 |     1 |
|  2 |    10 |
| 11 |    12 |
|  3 |    20 |
|  4 |    22 |
|  9 |    44 |
|  8 |    50 |
|  6 |    70 |
|  5 |   500 |
+----+-------+
12 rows in set (0.08 sec)

mysql> SELECT * FROM warehouse ORDER by CASE WHEN value=0 THEN 1 ELSE 0 END;
+----+-------+
| id | value |
+----+-------+
|  1 |     1 |
|  2 |    10 |
|  3 |    20 |
|  4 |    22 |
|  5 |   500 |
|  6 |    70 |
|  8 |    50 |
|  9 |    44 |
| 11 |    12 |
|  7 |     0 |
| 10 |     0 |
| 12 |     0 |
+----+-------+
12 rows in set (0.08 sec)


Практическое задание теме «Агрегация данных»
1. Подсчитайте средний возраст пользователей в таблице users.
SELECT AVG(age) as 'avg_age' 
FROM
	( SELECT DATE_FORMAT( now(), '%Y' ) - DATE_FORMAT( `profiles`.birthday, '%Y' ) AS age FROM `profiles` ) AS t_1

2. Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели. 
Следует учесть, что необходимы дни недели текущего года, а не года рождения.
SELECT
	WEEK_DAY, `count`
FROM
	(
	SELECT
		DATE_FORMAT( DATE_FORMAT( `profiles`.birthday, '2020-%m-%d' ), '%w' ) AS 'WEEK_DAY_INT',
		DATE_FORMAT( DATE_FORMAT( `profiles`.birthday, '2020-%m-%d' ), '%W' ) AS 'WEEK_DAY',
		COUNT( 1 ) AS 'count' 
	FROM
		vk.`profiles` 
	GROUP BY
		WEEK_DAY 
	ORDER BY
		WEEK_DAY_INT 
	) AS t_1 
	ORDER BY IF( `WEEK_DAY_INT` = 0, 1, 0 )


